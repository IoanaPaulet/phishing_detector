// üéØ PHISHING DETECTOR - BACKGROUND SCRIPT FINAL
// PƒÉstreazƒÉ COMPLET algoritmul original + adaugƒÉ ensemble cu Python server



const phishingKeywords = [
  'urgent', 'verify', 'banking', 'password', 'credit card', 'social security',
  'click', 'suspicious', 'required', 'limited', 'expire', 'paypal', 'atm', 
  'authenticate', 'validation', 'fraud', 'lottery', 'winning', 'prize', 'claim',
  'congrats', 'congratulation', 'gift', 'free', 'unexpected', 'inheritance', 
  'suspended', 'unauthorized', 'immediate', 'action', 'invoice',
  'limited time', 'offer', 'tax', 'refund', 'wire transfer', 'money',
  'bitcoin', 'crypto', 'investment', 'double', 'profit', 'beneficiary', 
  'identity', 'theft', 'compromise', 'hacked', 'restriction', 'disable', 
  'urgent', 'verificƒÉ', 'bancƒÉ', 'parolƒÉ', 'card de credit', 'securitate socialƒÉ',
  'clic', 'suspect', 'necesar', 'limitat', 'expirƒÉ', 'platƒÉ', 'bancomat', 
  'autentificare', 'validare', 'fraudƒÉ', 'loterie', 'c√¢»ôtig', 'premiu', 'revendicare',
  'felicitƒÉri', 'cadou', 'gratuit', 'nea»ôteptat', 'mo»ôtenire', 
  'suspendat', 'neautorizat', 'imediat', 'ac»õiune', 'facturƒÉ',
  'timp limitat', 'ofertƒÉ', 'impozit', 'rambursare', 'transfer bancar', 'bani',
  'bitcoin', 'crypto', 'investi»õie', 'dublu', 'profit', 'beneficiar', 
  'identitate', 'furt', 'compromis', 'hacked', 'restric»õie', 'dezactivare'
];

const suspiciousDomains = [
  'bit.ly', 'tinyurl.com', 'goo.gl', 't.co', 'ow.ly', 'is.gd', 
  'buff.ly', 'adf.ly', 'tiny.cc', 'clck.ru', 'pixelme.me', 
  'cutt.ly', 'shorturl.at', 'rebrand.ly', 'j.mp', 'urly.co'
];

const financialServices = [
  'paypal', 'visa', 'mastercard', 'americanexpress', 'banking', 
  'bank', 'western union', 'moneygram', 'revolut', 'transferwise', 
  'stripe', 'square', 'citibank', 'hsbc', 'chase', 'wellsfargo'
];

const sensitivePatterns = [
  /enter.{1,20}(password|credentials)/i,
  /(confirm|update|verify).{1,20}(details|information)/i,
  /(credit\.?card|card\.?number)/i,
  /(social\.?security|SSN)/i,
  /(account\.?number|routing\.?number)/i,
  /(PIN|personal\.?identification\.?number)/i,
  /(username|user\.?id).{1,20}(and|&).{1,20}password/i,
  /bank.{1,30}(details|login|account)/i,
  /(tax|financial).{1,20}information/i
];

const urgencyPhrases = [
  'urgent', 'immediate', 'action required', 'alert', 'warning', 
  'critical', 'limited time', 'expire',
  'urgent', 'imediat', 'ac»õiune necesarƒÉ', 'alertƒÉ', 'avertisment',
  'critic', 'timp limitat', 'expirƒÉ'
];

const trustedSenders = [
  "newsletter@company.com",
  "support@google.com",
  "no-reply@linkedin.com", 
  "info@amazon.com",
  "notifications@github.com",
  "news@medium.com",
  "noreply@youtube.com",
  "billing@microsoft.com"
];

/**
 * üîÑ FUNC»öIA TA ORIGINALƒÇ HIBRIDƒÇ (PƒÇSTRATƒÇ EXACT)
 * DetecteazƒÉ phishing folosind algoritmul original complet
 */
function detectPhishingWithAI(emailData) {
  const subject = emailData.subject || '';
  const body = emailData.body || '';
  const links = emailData.links || [];
  const sender = emailData.sender || '';
  
  // VerificƒÉ trusted senders
  if (trustedSenders.some(trusted => sender.toLowerCase().includes(trusted))) {
    console.log('Expeditor de √Æncredere detectat:', sender);
    return {
      isPhishing: false,
      score: 0,
      reasons: ["Expeditor de √Æncredere"],
      method: "hybrid_trusted"
    };
  }
  
  const text = subject + ' ' + body;
  const textLower = text.toLowerCase();
  
  let score = 0.0;
  const reasons = [];
  const debugInfo = {}; 
  
  // 1. Cuvinte cheie
  let keywordCount = 0;
  const keywordsDetected = [];
  
  for (const keyword of phishingKeywords) {
    if (textLower.includes(keyword)) {
      keywordCount++;
      keywordsDetected.push(keyword);
      if (keywordCount <= 3) { 
        reasons.push(`Email-ul con»õine cuv√¢ntul de alertƒÉ '${keyword}'`);
      }
    }
  }
  
  if (keywordCount > 0) {
    const keywordScore = Math.min(0.25, keywordCount * 0.05);
    score += keywordScore;
    debugInfo.keywordScore = keywordScore;
    debugInfo.keywordsDetected = keywordsDetected;
  }
  
  // 2. Link-uri suspecte
  let suspiciousLinkCount = 0;
  const suspiciousLinks = [];
  
  for (const link of links) {
    try {
      const domainMatch = link.match(/https?:\/\/([^\/]+)/);
      if (domainMatch) {
        const domain = domainMatch[1];
        if (suspiciousDomains.some(sd => domain.includes(sd))) {
          suspiciousLinkCount++;
          suspiciousLinks.push(domain);
          if (suspiciousLinkCount <= 2) { 
            reasons.push(`Link suspect: ${domain} (serviciu de scurtare URL)`);
          }
        }
      }
    } catch (error) {
      console.error("Eroare la procesarea link-ului:", error);
    }
  }
  
  if (suspiciousLinkCount > 0) {
    const linkScore = Math.min(0.3, suspiciousLinkCount * 0.15);
    score += linkScore;
    debugInfo.linkScore = linkScore;
    debugInfo.suspiciousLinks = suspiciousLinks;
  }
  
  // 3. Informa»õii sensibile
  let sensitiveInfoDetected = false;
  
  for (const pattern of sensitivePatterns) {
    if (pattern.test(textLower)) {
      reasons.push("Email-ul solicitƒÉ informa»õii personale sau financiare sensibile");
      score += 0.3;
      sensitiveInfoDetected = true;
      debugInfo.sensitiveInfoScore = 0.3;
      break;
    }
  }

  // 4. Servicii financiare mismatch
  let misusedServiceDetected = false;
  let misusedService = '';
  
  for (const service of financialServices) {
    if (textLower.includes(service)) {
      let serviceLinkFound = false;
      for (const link of links) {
        if (link.toLowerCase().includes(service)) {
          serviceLinkFound = true;
          break;
        }
      }
      
      if (!serviceLinkFound && links.length > 0) {
        reasons.push(`Email-ul men»õioneazƒÉ '${service}' dar link-urile nu duc la site-ul oficial`);
        score += 0.3;
        misusedServiceDetected = true;
        misusedService = service;
        debugInfo.misusedServiceScore = 0.3;
        break;
      }
    }
  }

  // 5. Urgen»õƒÉ
  let urgencyDetected = false;
  let urgencyPhrase = '';
  
  for (const phrase of urgencyPhrases) {
    if (textLower.includes(phrase)) {
      reasons.push("Email cu tonalitate urgentƒÉ pentru a grƒÉbi ac»õiunea utilizatorului");
      score += 0.15; 
      urgencyDetected = true;
      urgencyPhrase = phrase;
      debugInfo.urgencyScore = 0.15;
      break;
    }
  }
  
  // 6. Pattern-uri phishing
  let patternMatchCount = 0;
  const patternMatches = [];
  
  const phishingPatterns = [
    /(we.{1,10}detected.{1,20}suspicious)/i,
    /(verify.{1,10}account.{1,10}prevent)/i,
    /(unusual.{1,10}activity)/i,
    /(security.{1,10}measure)/i,
    /(limited.{1,10}time.{1,10}offer)/i,
    /(click.{1,10}link.{1,10}below)/i,
    /(update.{1,10}information)/i,
    /(payment.{1,10}declined)/i,
    /(account.{1,10}suspended)/i,
    /(prize.{1,10}claim)/i
  ];
  
  for (const pattern of phishingPatterns) {
    if (pattern.test(text)) {
      patternMatchCount++;
      patternMatches.push(pattern.toString());
    }
  }
  
  if (patternMatchCount >= 2) {
    reasons.push("Analiza AI a detectat tipare lingvistice asociate cu phishing-ul");
    score += 0.2; 
    debugInfo.patternMatchScore = 0.2;
    debugInfo.patternMatches = patternMatches;
  }

  // NormalizeazƒÉ scorul
  score = Math.max(0, Math.min(1, score));
  const isPhishing = score > 0.7;
  
  if (reasons.length > 5) {
    reasons.splice(5);
  } else if (reasons.length === 0) {
    reasons.push("Nu am identificat motive specifice de √Ængrijorare.");
  }

  console.log('AnalizƒÉ phishing hibrid (original):', {
    score: score,
    isPhishing: isPhishing,
    subject: subject,
    debug: debugInfo
  });
  
  return {
    isPhishing: isPhishing,
    score: score,
    reasons: reasons,
    method: "hybrid_algorithm_original",
    debugInfo: debugInfo
  };
}

// ============================================
// ENSEMBLE CU PYTHON SERVER (NOU)
// ============================================

const PYTHON_SERVER_URL = 'http://127.0.0.1:5000';

/**
 * üéØ ENSEMBLE: CombinƒÉ algoritmul original cu Python server
 * DacƒÉ Python server e disponibil, folose»ôte ensemble
 * DacƒÉ nu, folose»ôte doar algoritmul original
 */
async function detectPhishingWithEnsemble(emailData) {
  try {
    console.log('üéØ Attempting ensemble analysis...', emailData);
    
    // √éncearcƒÉ sƒÉ contacteze Python server-ul
    const response = await fetch(`${PYTHON_SERVER_URL}/analyze-email`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(emailData),
      timeout: 5000  // 5 secunde timeout
    });
    
    if (!response.ok) {
      throw new Error(`Server responded with status: ${response.status}`);
    }
    
    const ensembleResult = await response.json();
    console.log('‚úÖ Ensemble result from Python server:', ensembleResult);
    
    // Converte»ôte rezultatul pentru compatibilitate cu extensia
    return {
      isPhishing: ensembleResult.isPhishing,
      score: ensembleResult.score,
      reasons: ensembleResult.reasons,
      method: ensembleResult.method,
      breakdown: ensembleResult.breakdown
    };
    
  } catch (error) {
    console.warn('‚ö†Ô∏è Python server unavailable, using original hybrid algorithm:', error.message);
    
    // Fallback la algoritmul tƒÉu original
    const hybridResult = detectPhishingWithAI(emailData);
    hybridResult.method = 'hybrid_fallback_python_unavailable';
    hybridResult.note = 'Python server unavailable - using original algorithm';
    
    return hybridResult;
  }
}

/**
 * üîç VerificƒÉ dacƒÉ Python server-ul ruleazƒÉ
 */
async function checkPythonServerHealth() {
  try {
    const response = await fetch(`${PYTHON_SERVER_URL}/health`, {
      method: 'GET',
      timeout: 3000
    });
    
    if (response.ok) {
      const health = await response.json();
      console.log('üü¢ Python server status:', health);
      return health;
    }
    
    throw new Error(`Health check failed: ${response.status}`);
    
  } catch (error) {
    console.log('üî¥ Python server not available:', error.message);
    return null;
  }
}

// ============================================
// MESSAGE HANDLERS (PƒÇSTRAT DIN ORIGINAL)
// ============================================

chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  if (message.action === 'analyzeEmail') {
    console.log('üì® Received email analysis request:', message.data);
    
    // Folose»ôte ensemble (cu fallback la hibrid original)
    detectPhishingWithEnsemble(message.data)
      .then(result => {
        // SalveazƒÉ rezultatul pentru popup
        chrome.storage.local.set({ 
          lastAnalysis: {
            timestamp: Date.now(),
            data: message.data,
            result: result
          }
        });
        
        // Afi»ôeazƒÉ warning dacƒÉ e phishing
        if (result.isPhishing) {
          chrome.tabs.sendMessage(sender.tab.id, {
            action: 'showWarning',
            isPhishing: result.isPhishing,
            score: result.score,
            reasons: result.reasons
          });
        }
        
        // Log pentru debugging
        console.log('üìä Final analysis result:', {
          method: result.method,
          score: result.score,
          isPhishing: result.isPhishing,
          pythonServerUsed: !result.method.includes('fallback')
        });
        
        sendResponse(result);
      })
      .catch(error => {
        console.error('‚ùå Critical error in analysis:', error);
        
        // Ultimate fallback la algoritmul original
        const fallbackResult = detectPhishingWithAI(message.data);
        fallbackResult.method = 'hybrid_critical_fallback';
        fallbackResult.error = error.message;
        
        sendResponse(fallbackResult);
      });
    
    return true; // Async response
  }
  
  // Handler pentru verificarea stƒÉrii Python server
  if (message.action === 'checkPythonServer') {
    checkPythonServerHealth()
      .then(health => sendResponse(health))
      .catch(() => sendResponse(null));
    
    return true;
  }
});

// ============================================
// INI»öIALIZARE (PƒÇSTRATƒÇ DIN ORIGINAL)
// ============================================

chrome.runtime.onStartup.addListener(() => {
  console.log('üöÄ Phishing Detector Extension started (Ensemble mode)');
  checkPythonServerHealth();
});

chrome.runtime.onInstalled.addListener(() => {
  console.log('üì¶ Phishing Detector Extension installed (Ensemble mode)');
  console.log('üéØ Algorithm: Original hibrid + Python ensemble (30% RF + 70% hibrid)');
  console.log('üîÑ Fallback: Original hibrid algorithm if Python unavailable');
  checkPythonServerHealth();
});

// Test ini»õial la √ÆncƒÉrcarea script-ului
console.log('üîß Background script loaded - Ensemble mode with original algorithm fallback');
console.log('üì° Python server expected at: http://127.0.0.1:5000');
console.log('üéØ Ensemble: 30% RandomForest + 70% Algoritm hibrid original');
console.log('üîÑ Fallback: 100% Algoritm hibrid original (dacƒÉ Python nu e disponibil)');

// Verificare ini»õialƒÉ Python server
checkPythonServerHealth();